<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- SAVED from url=(0043)http://srfi.schemers.org/srfi-template.html -->
<HTML>
<HEAD>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>SRFI 31: A generalised A. Church procedure form</title> </HEAD>

<BODY>

<H1>Title</H1>

A generalised A. Church procedure form

<H1>Version</H1> 

<UL>

<LI>
Sun May 26 09:10:44 2002. Improved exposition without changing
semantics.</LI>

<LI>
Thu May 23 18:14:42 2002. Submitted first version to
srfi-editors@srfi.schemers.org.</LI>

</UL>

<H1>Author</H1>

 Mirko Luedde &lt;<A
href="mailto:Mirko.Luedde@Computer.Org">Mirko.Luedde@Computer.Org</A>&gt;

<H1>Status</H1>
 
This SRFI is currently in ``draft'' status. To see an explanation of
each status that a SRFI can hold, see <A
href="http://srfi.schemers.org/srfi-process.html">here</A>.  It will
remain in draft until 2002-08-24, or as amended.  to provide input on
this SRFI, please <A href="mailto:srfi-31@srfi.schemers.org"> mail to
<CODE>srfi-31@srfi.schemers.org</CODE></A>.  See <A
href="http://srfi.schemers.org/srfi-list-subscribe.html"> instructions
here</A> to subscribe to the list.  You can access previous messages
via <A
href="http://srfi.schemers.org/srfi-31/mail-archive/maillist.html">
the archive of the mailing list</A>.
    
<UL>
  <LI>Draft: 2002/05/24-2002/08/24</LI>
</UL>

<H1>Abstract</H1>

 We propose the implementation of a new special form
called <CODE>procedure</CODE>. This form allows the simple and
stateless construction of recursive procedures. It extends the
A. Church form <CODE>lambda</CODE> in that it allows recursive
definitions without the need of using further special forms like
<CODE>let</CODE> or <CODE>letrec</CODE> or advanced constructions like
the H. B. Curry combinator. Unlike <CODE>define</CODE>, the form
<CODE>procedure</CODE> is non-imperative, hence does not operate on
storage and does not introduce a variable binding in its scope.

<H1>Issues</H1>

 No issues are anticipated.

<H1>Rationale</H1> 

<H2>General</H2> Among the prominent features of the Scheme
programming language are the following.

<OL>

 <LI>It has simple syntax.</LI>
 
 <LI>It encourages recursive procedure definitions, e.g. by ensuring
     memory efficient tail recursion.</LI>

 <LI>It supports stateless (non-imperative) programming.</LI>

</OL>

Therefore Scheme is particularly suited for research and teaching in
recursion theory. Nevertheless Scheme does not provide a syntax for
procedure definitions with the properties of

<OL>

<LI>being as simple and intuitive as possible,</LI>

<LI>allowing general recursion,</LI>

<LI>being stateless.</LI>

</OL>

<H2>Example</H2> Let us look at the factorial function. In
mathematical notation this function is expressed as

<PRE> 
  (F : N |--> 1,            if N = 0; 
              N * F(N - 1), otherwise).
</PRE>

This expression is just a name for the factorial. Hence the following
is a syntactically correct mathematical assertion.

<PRE>
  The function (F : N |--> 1, if N = 0; N * F(N – 1), otherwise) is
  not polynomially bounded.</PRE>

<P>We investigate some approaches to express the factorial function in
Scheme.

<OL>

<LI>
The simplest way perhaps is as follows.

<PRE>
(define (F N) 
  (if (zero? N) 1 
    (* N (F (- N 1)))))
</PRE>

This Scheme expression is a more or less straightforward translation
from the mathematical mixed infix/prefix notation to a pure prefix
notation.  Despite this syntactical similarity, there is a difference
in semantics.

<UL> 

<LI>The Scheme expression is not a name for the factorial. It may not
occur in a context where a name of the factorial is required.</LI>

<LI>The Scheme expression is a command that introduces the name
<CODE>F</CODE> for the factorial. A change of state is involved by
binding the factorial function to the variable <CODE>F</CODE>. Hence
we need a storage model in order to understand the semantics.</LI>

</UL>

</LI>

<LI>
Here are some possibilities for implementing the factorial in a
different way.

<PRE>
(letrec ( (G (lambda (N) 
	       (if (zero? N) 1 
		 (* N (G (- N 1)))))) )	G)
</PRE>

<PRE>
(lambda (N) 
  (let G ( (m N) ) 
       (if (zero? m) 1 
	 (* m (G (- m 1))))))
</PRE>

These expressions define the factorial anonymously, not binding it to
a variable. However, the following objections may be made.

<UL>

<LI>The expressions are more remote from the mathematical notation
than the <CODE>define</CODE> form. Therefore they are less intuitive.

<LI>They introduce further special forms <CODE>letrec</CODE> and
<CODE>let</CODE>, respectively.</LI>

<LI>When defining the semantics of these expressions, the use of
<CODE>letrec</CODE> or <CODE>let</CODE> again requires the notion of
storage, as in both cases variable bindings occur.</LI>

</UL>

</LI>

<LI>
We can avoid using <CODE>letrec</CODE> and <CODE>let</CODE> relying
solely on <CODE>lambda</CODE>, when we are willing to make use of
H. B. Curry combinatorial expressions. But also this approach is not
satisfying for the following reasons.

<UL>

<LI>The syntax gets even more involved.</LI>

<LI>The semantics gets more complicated as higher order procedures are
required.</LI>

<LI>Procedures of multiple arguments need currying.</LI>

</UL>

</OL>

<H2>Proposal</H2> Thus, we propose to denote the factorial simply by

<PRE>
(procedure (F N) 
	   (if (zero? N) 1 
	     (* N (F (- N 1)))))
</PRE>

with similar syntax and semantics as the <CODE>define</CODE>
expression above. But <CODE>procedure</CODE> does not introduce an
external binding of the variable <CODE>F</CODE>. The variable
<CODE>F</CODE> is confined inside the expression in the same way as is
the argument variable <CODE>N</CODE>.

<P>We can also define the factorial in a tail recursive way.

<PRE>
(procedure (F N)
 ((procedure (G K L)
   (if (zero? K) L
    (G (- K 1) (* K L)))) N 1))
</PRE>

Note that neither in the external scope, nor in the interior scope of
the outer <CODE>procedure</CODE> expression any variable bindings are
performed. All variable occurrences are confined.

<H1>Specification</H1>

<H2>Syntax</H2> 

<OL>

<LI><CODE>&lt;PROCEDURE-EXPRESSION&gt;</CODE>: <CODE>(procedure
   (&lt;TAG&gt; . &lt;VARIABLE-LIST&gt;) &lt;BODY&gt;)</CODE>.</LI>

<LI><CODE>&lt;TAG&gt;</CODE>: any Scheme symbol.</LI>

<LI><CODE>&lt;VARIABLE-LIST&gt;</CODE>: any list of Scheme
   symbols.</LI>

<LI><CODE>&lt;BODY&gt;</CODE>: any (sequence of) expression(s) that is
allowed in the body of a lambda expression.</LI>

</OL>

<H2>Semantics</H2> 

Let <EM>T</EM> be a symbol. Let <EM>V</EM> be a list of symbols.  Let
<EM>B</EM> be a body expression.  Let <EM>E</EM> be an environment in
which the expression

<PRE>(define (<EM>T</EM> . <EM>V</EM>) <EM>B</EM>)</PRE>

has been evaluated.

Then in <EM>E</EM> the expression <EM>T</EM> is equivalent to any
expression

<PRE>(procedure (<EM>T2</EM> . <EM>L</EM>) <EM>B2</EM>)</PRE>

where <EM>T2</EM> is a symbol and <EM>B2</EM> is the substitution of
<EM>T</EM> by <EM>T2</EM> in <EM>B</EM>, assuming <EM>T</EM> is free
for <EM>T2</EM> in <EM>B</EM>.

<H2>Properties</H2>

The special form <CODE>procedure</CODE> has the following properties.

<OL>

<LI>Its syntax is quite similar to existing Scheme syntax and is close
to the mathematical standard notation.</LI>

<LI>It is a proper extension of the <CODE>lambda</CODE> form, not
requiring <CODE>let</CODE>, <CODE>letrec</CODE> or the H. B. Curry
combinator in order to express general recursions.</LI>

<LI>As long as we use the form for defining functions rather than
procedures, the concept of storage is not needed for defining the
semantics.</LI>

</OL>

<H1>Implementation</H1>

<H2>Macro</H2>

Scheme versions providing <CODE>define-syntax</CODE>,
<CODE>syntax-rules</CODE>, <CODE>letrec</CODE> and <CODE>lambda</CODE>
might implement <CODE>procedure</CODE> as follows.

<PRE>
(define-syntax procedure
  (syntax-rules ()
    ((_ (TAG . VARIABLE-LIST) BODY)
     (letrec ( (TAG (lambda VARIABLE-LIST BODY)) )
       TAG))))
</PRE>

<H2>Simple test</H2>

The following session shows an application of the macro.

<PRE>
> (define-syntax procedure
  (syntax-rules ()
    ((_ (TAG . VARIABLE-LIST) BODY)
     (letrec ( (TAG (lambda VARIABLE-LIST BODY)) )
       TAG))))
> (define F (procedure (F N)
		((procedure (G K L)
		   (if (zero? K) L
		     (G (- K 1) (* K L)))) N 1))
> F
#&lt;procedure&gt;
> (F 0)
1
> (F 10)
3628800
> (exit) 
</PRE>

<H1>Copyright</H1>

Copyright (C) Dr. Mirko Luedde (2002). All Rights Reserved. 

<P>
This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Scheme Request For
Implementation process or editors, except as needed for the purpose of
developing SRFIs in which case the procedures for copyrights defined
in the SRFI process must be followed, or as required to translate it
into languages other than English.

<P>
The limited permissions granted above are perpetual and will not be
revoked by the authors or their successors or assigns.

<P>
This document and the information contained herein is provided on an
"AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.

<HR>

<ADDRESS>Author: <A href="mailto:Mirko.Luedde@Computer.Org">Mirko
Luedde</A></ADDRESS>

<ADDRESS>Editor: <A
href="mailto:srfi-editors@srfi.schemers.org">Francisco
Solsona</A></ADDRESS>

</BODY>

</HTML>
