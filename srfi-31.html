<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- SAVED from url=(0043)http://srfi.schemers.org/srfi-template.html -->
<html>
  <head>
    <META http-equiv=Content-Type content="text/html; charset=windows-1252">
    <title>SRFI 31: A special form for recursive evaluation</title>
  </head>

  <body>

<H1>Title</H1>

A special form for recursive evaluation

<H1>Version</H1> 

<UL>

<LI>
Sun Jun 9 17:44:38 2002. Changed title. Generalized semantics and
renamed <CODE>procedure</CODE> to <CODE>rec</CODE> as suggested by Al
Petrofsky.  </LI>

<LI>
Fri May 31 08:09:19 2002. Corrected some typos.</LI>

<LI>
Sun May 26 09:10:44 2002. Improved exposition without changing
semantics.</LI>

<LI>
Thu May 23 18:14:42 2002. Submitted first version to
srfi-editors@srfi.schemers.org.</LI>

</UL>

<H1>Author</H1>

 Mirko Luedde &lt;<A
href="mailto:Mirko.Luedde@Computer.Org">Mirko.Luedde@Computer.Org</A>&gt;

<H1>Status</H1>
 
This SRFI is currently in ``draft'' status. To see an explanation of
each status that a SRFI can hold, see <A
href="http://srfi.schemers.org/srfi-process.html">here</A>.  It will
remain in draft until 2002-08-24, or as amended.  To provide input on
this SRFI, please mail to <A
href="mailto:srfi-31@srfi.schemers.org"><CODE>srfi-31@srfi.schemers.org</CODE></A>.
See <A
href="http://srfi.schemers.org/srfi-list-subscribe.html">instructions</A>
to subscribe to the list.  You can access previous messages via the <A
href="http://srfi.schemers.org/srfi-31/mail-archive/maillist.html">archive</A>
of the mailing list.
    
<UL>
  <LI>Draft: 2002/05/24-2002/08/24</LI>
</UL>

<H1>Abstract</H1>

 We propose the implementation of a special form
called <CODE>rec</CODE>.  This form is a generalization of the forms
<CODE>rec</CODE> and <CODE>named-lambda</CODE> of <A
href="#[Clinger1985]">[Clinger1985]</A>. It allows the simple and
non-imperative construction of self-referential expressions.  As an
important special case, it extends the A. Church form
<CODE>lambda</CODE> in that it allows the direct definition of
recursive procedures without using further special forms like
<CODE>let</CODE> or <CODE>letrec</CODE>, without using advanced
constructions like the H. B. Curry combinator and, unlike
<CODE>define</CODE>, without introducing variable bindings in its
exterior scope.

<H1>Issues</H1>

 No issues are anticipated.

<H1>Rationale</H1> 

<H2>General</H2> Among the prominent features of the Scheme
programming language as defined in <a href="#[KCR1998]">[KCR1998]</a>
are the following.

<OL>

 <LI>It has simple syntax.</LI>
 
 <LI>It encourages recursive definitions, e.g. by ensuring memory
     efficient tail recursion.</LI>

 <LI>It supports non-imperative programming.</LI>

</OL>

Therefore Scheme is particularly suited for research and teaching in
recursion theory. 

<P>Nevertheless Scheme does not provide a syntax for recursive
evaluations with the properties of

<OL>

<LI>being as simple and intuitive as possible,</LI>

<LI>allowing general recursion,</LI>

<LI>being non-imperative.</LI>

</OL>

<H2>Example</H2> 

We provide two examples illustrating special cases of what we think is
missing from the specification <A href="#[KCR1998]">[KCR1998]</A>.

<H3>Problem 1</H3> 

Let us look at the factorial function. In mathematical notation this
function is expressed as

<PRE> 
  (F : N |--> 1,            if N = 0; 
              N * F(N - 1), otherwise).
</PRE>

This expression is just a name for the factorial. Hence the following
is a syntactically correct mathematical assertion.

<PRE>
  The function (F : N |--> 1, if N = 0; N * F(N – 1), otherwise) is
  not polynomially bounded.</PRE>

<P>We investigate some approaches to express the factorial function in
Scheme.

<OL>

<LI>
The simplest way perhaps is as follows.

<PRE>
(define (F N) 
  (if (zero? N) 1 
    (* N (F (- N 1)))))
</PRE>

This Scheme expression is a more or less straightforward translation
from the mathematical mixed infix/prefix notation to a pure prefix
notation.  Despite this syntactical similarity, there is a difference
in semantics.

<UL> 

<LI>The Scheme expression is not a name for the factorial. It may not
occur in a context where a name of the factorial is required.</LI>

<LI>The Scheme expression is an imperative that introduces the name
<CODE>F</CODE> for the factorial. A change of state is involved by
binding the factorial function to the variable <CODE>F</CODE>. Hence
we need a storage model in order to understand the semantics.</LI>

</UL>

</LI>

<LI>
Here are some possibilities for implementing the factorial in a
different way.

<PRE>
(letrec ( (G (lambda (N) 
	       (if (zero? N) 1 
		 (* N (G (- N 1)))))) )	G)
</PRE>

<PRE>
(lambda (N) 
  (let G ( (m N) ) 
       (if (zero? m) 1 
	 (* m (G (- m 1))))))
</PRE>

These expressions define the factorial anonymously, not binding it to
a variable. However, the following objections may be made.

<UL>

<LI>The expressions are more remote from the mathematical notation
than the <CODE>define</CODE> form. Therefore they are less intuitive.

<LI>They introduce further special forms <CODE>letrec</CODE> and
<CODE>let</CODE>, respectively.</LI>

<LI>When defining the semantics of these expressions, the use of
<CODE>letrec</CODE> or <CODE>let</CODE> again requires the notion of
storage, as in both cases variable bindings occur.</LI>

</UL>

</LI>

<LI>
We can avoid using <CODE>letrec</CODE> and <CODE>let</CODE> relying
solely on <CODE>lambda</CODE>, when we are willing to make use of
H. B. Curry combinatorial expressions. But also this approach is not
satisfying for the following reasons.

<UL>

<LI>The syntax gets even more involved.</LI>

<LI>The semantics gets more complicated as higher order procedures are
required.</LI>

<LI>Procedures of multiple arguments need currying.</LI>

</UL>

</OL>

<H3>Solution 1</H3> 

A solution to our example problem was already provided in <A
href="#[Clinger1985]">[Clinger1985]</A> by the form
<CODE>named-lambda</CODE>. (An even earlier solution with a slightly
different syntax was implemented in Kent Dybvig's Chez Scheme system.)

Using this special form, we would denote the factorial simply by

<PRE>
(named-lambda (F N) 
              (if (zero? N) 1 
                (* N (F (- N 1)))))
</PRE>

with similar syntax and semantics as the <CODE>define</CODE>
expression above. But <CODE>named-lambda</CODE> is non-imperative, it
does not introduce an external binding of the variable
<CODE>F</CODE>. The variable <CODE>F</CODE> is confined inside the
expression in the same way as is the argument variable <CODE>N</CODE>.

<P>However, this form has been dropped from later versions of the
Scheme Report. Also it is missing in state-of-the-art implementations
such as Chez Scheme (6.0a) and MIT Scheme (7.7.0). (The latter
actually knows a form <CODE>named-lambda</CODE> with different
semantics).

<H3>Problem 2</H3> 

We have seen that sometimes we'd like to define an expression with
reference to itself.  The <CODE>named-lambda</CODE> form allowed to do
this in the special case of procedure definitions.  A similar problem
with self-referential expressions can occur also in different
contexts.

<P>E.g., the constant stream of ones can be defined via

<PRE>(define S (cons 1 (delay S)))</PRE>

As in the case of the factorial, we are able to define the recursive
object at the price of spending an externally bound name. Remedying
this with <CODE>let</CODE> or <CODE>letrec</CODE> leads to similar
objections as above.

<H3>Solution 2</H3> 

This particular case of the self-referential problem was solved by the
<CODE>rec</CODE> form in <A href="#[Clinger1985]">[Clinger1985]</A>.

With the help of this form, a name for the constant stream of ones 
is given by the expression 

<PRE> (rec S (cons 1 (delay S))) </PRE>

This expression is non-imperative and does not introduce an external
variable binding.

<P>Also this form has been dropped from later versions of the Scheme
Report. Moreover, from our point of view this form alone is not
capable of solving Problem 1. The respective definition would look
like

<PRE>
(rec F (lambda (N) 
               (if (zero? N) 1 
                 (* N (F (- N 1))))))
</PRE>

which does not seem quite as simple and intuitive as the mathematical
notation.

<H2>Proposal</H2> 

We therefore propose to implement the <CODE>rec</CODE> special form in
a generalized form in order to allow recursive procedure definitions
as in

<PRE>
(rec (F N) 
     (if (zero? N) 1 
       (* N (F (- N 1)))))
</PRE>

<H1>Specification</H1>

<H2>Syntax</H2> 

<OL>

<LI><CODE>&lt;REC-EXPRESSION&gt;</CODE>:
<CODE>&lt;REC-CONSTANT&gt;</CODE> or
<CODE>&lt;REC-PROCEDURE&gt;</CODE>.</LI>

<LI><CODE>&lt;REC-CONSTANT&gt;</CODE>: <CODE>(rec &lt;TAG&gt;
&lt;EXPRESSION&gt;)</CODE>.</LI>

<LI><CODE>&lt;REC-PROCEDURE&gt;</CODE>: <CODE>(rec
   (&lt;TAG&gt; . &lt;VARIABLE-LIST&gt;) &lt;BODY&gt;)</CODE>.</LI>

<LI><CODE>&lt;TAG&gt;</CODE>: any Scheme symbol.</LI>

<LI><CODE>&lt;EXPRESSION&gt;</CODE>: any Scheme expression.</LI>

<LI><CODE>&lt;VARIABLE-LIST&gt;</CODE>: any list of Scheme
   symbols.</LI>

<LI><CODE>&lt;BODY&gt;</CODE>: any (sequence of) expression(s) that is
allowed in the body of a lambda expression.</LI>

</OL>

<H2>Semantics</H2> 

<H3><CODE>rec</CODE>-Constants</H3> 

Let <EM>T</EM> be a symbol. Let <EM>X</EM> be an expression.  Let
<EM>E</EM> be an environment in which the expression

<PRE>(define <EM>T</EM> <EM>X</EM>)</PRE>

has been evaluated.

Then in <EM>E</EM> the expression <EM>T</EM> is equivalent to any
expression

<PRE>(rec <EM>T2</EM> <EM>X2</EM>)</PRE>

where <EM>T2</EM> is a symbol and <EM>X2</EM> is the substitution of
<EM>T</EM> by <EM>T2</EM> in <EM>X</EM>, assuming <EM>T</EM> is free
for <EM>T2</EM> in <EM>X</EM>.

<H3><CODE>rec</CODE>-Procedures</H3> 

Let <EM>T</EM> be a symbol. Let <EM>V</EM> be a list of symbols.  Let
<EM>B</EM> be a body expression.  Let <EM>E</EM> be an environment in
which the expression

<PRE>(define (<EM>T</EM> . <EM>V</EM>) <EM>B</EM>)</PRE>

has been evaluated.

Then in <EM>E</EM> the expression <EM>T</EM> is equivalent to any
expression

<PRE>(rec (<EM>T2</EM> . <EM>L</EM>) <EM>B2</EM>)</PRE>

where <EM>T2</EM> is a symbol and <EM>B2</EM> is the substitution of
<EM>T</EM> by <EM>T2</EM> in <EM>B</EM>, assuming <EM>T</EM> is free
for <EM>T2</EM> in <EM>B</EM>.

<H2>Properties</H2>

The special form <CODE>rec</CODE> has the following properties.

<OL>

<LI>It is a proper extension of the <CODE>rec</CODE> and the
<CODE>named-lambda</CODE> forms of <A
href="#[Clinger1985]">[Clinger1985]</A>.</LI>

<LI>When used for recursive procedure definitions, its syntax is quite
similar to the mathematical standard notation.</LI>

<LI>It is a proper extension of the <CODE>lambda</CODE> form, not
requiring <CODE>let</CODE>, <CODE>letrec</CODE> or the H. B. Curry
combinator in order to express general recursions.</LI>

<LI>As long as we use the form for defining functions rather than
procedures, the concept of storage is not needed for defining the
semantics.</LI>

</OL>

<H1>Implementation</H1>

<H2>Macro</H2>

Scheme versions such as <A href="#[KCR1998]">[KCR1998]</A> providing
<CODE>define-syntax</CODE>, <CODE>syntax-rules</CODE>,
<CODE>letrec</CODE> and <CODE>lambda</CODE> might implement
<CODE>rec</CODE> as follows.

<PRE>
(define-syntax rec
  (syntax-rules ()
    ((rec (TAG . VARIABLE-LIST) . BODY)
     (letrec ((TAG (lambda VARIABLE-LIST . BODY))) TAG))
    ((rec TAG EXPRESSION)
     (letrec ((TAG EXPRESSION)) TAG))))
</PRE>

<H2>Simple test</H2>

The following session shows an application of the macro.

<PRE>
> (define F (rec (F N)
		((rec (G K L)
		   (if (zero? K) L
		     (G (- K 1) (* K L)))) N 1)))
> F
#&lt;procedure&gt;
> (F 0)
1
> (F 10)
3628800
</PRE>

<H1>Acknowledgements</H1> 

The author thanks Al Petrofsky for the final solution and Hal Abelson,
Chris Hanson and others for their input. The work of the maintainers
of the SRFI forum is highly appreciated.

<H1>Bibliography</H1>

<UL>

<LI>
<a name="[Clinger1985]">[Clinger1985]</a>
  EDITOR =	 {Clinger, W.},
  TITLE =	 {Draft of Report of the October 1984 Workshop on Scheme},
  JOURNAL =	 {Proceedings Brandeis Workshop Oct.~22--23, 1984},
  MONTH =	 {Mar},
  YEAR =	 {1985},
  URL =
{<A
HREF=http://www.swiss.ai.mit.edu/ftpdir/scheme-mail/HTML/rrrs-1985>http://www.swiss.ai.mit.edu/ftpdir/scheme-mail/HTML/rrrs-1985</A>}</LI>

<LI>
<a name="[KCR1998]">[KCR1998]</a>
  AUTHOR =	 {Kelsey, R. and Clinger, W. and Rees, J.},
  TITLE =	 {Revised (5) Report on the Algorithmic Language Scheme},
  JOURNAL =	 {Higher-Order and Symbolic Computation},
  VOLUME =	 {11},
  NUMBER =	 {1},
  MONTH =	 {Sep},
  YEAR =	 {1998}
</LI>
</UL>

<H1>Copyright</H1>

Copyright (C) Dr. Mirko Luedde (2002). All Rights Reserved. 

<P>
This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Scheme Request For
Implementation process or editors, except as needed for the purpose of
developing SRFIs in which case the procedures for copyrights defined
in the SRFI process must be followed, or as required to translate it
into languages other than English.

<P>
The limited permissions granted above are perpetual and will not be
revoked by the authors or their successors or assigns.

<P>
This document and the information contained herein is provided on an
"AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.

<HR>

<ADDRESS>Author: <A href="mailto:Mirko.Luedde@Computer.Org">Mirko
Luedde</A></ADDRESS>

<ADDRESS>Editor: <A
href="mailto:srfi-editors@srfi.schemers.org">Francisco
Solsona</A></ADDRESS>

</body>

</html>
